import {
  V3
} from "./chunk-G6ZQ3T5U.js";
import "./chunk-AYNHEKRI.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  children,
  claim_element,
  detach_dev,
  dispatch_dev,
  element,
  init,
  insert_hydration_dev,
  noop,
  onMount,
  safe_not_equal,
  validate_slots
} from "./chunk-DCE4O3CF.js";
import "./chunk-2GBBIY5G.js";
import "./chunk-V6TY7KAL.js";

// node_modules/@lottiefiles/dotlottie-svelte/dist/Dotlottie.svelte
var file = "node_modules/@lottiefiles/dotlottie-svelte/dist/Dotlottie.svelte";
function add_css(target) {
  append_styles(target, "svelte-1r5gmvu", "div.svelte-1r5gmvu{width:100%;height:100%}canvas.svelte-1r5gmvu{width:100%;height:100%;display:block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRG90bG90dGllLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvVXNlcnMvbXVycmF5YnVjaGFuYW4vTGlicmFyeS9Nb2JpbGUgRG9jdW1lbnRzL2NvbX5hcHBsZX5DbG91ZERvY3MvRG9jdW1lbnRzL3dlYnNpdGUvcGVyc29uYWwtd2Vic2l0ZS9ub2RlX21vZHVsZXMvQGxvdHRpZWZpbGVzL2RvdGxvdHRpZS1zdmVsdGUvZGlzdC9Eb3Rsb3R0aWUuc3ZlbHRlIl19 */");
}
function create_fragment(ctx) {
  let div;
  let canvas_1;
  const block = {
    c: function create() {
      div = element("div");
      canvas_1 = element("canvas");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      canvas_1 = claim_element(div_nodes, "CANVAS", { class: true });
      children(canvas_1).forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(canvas_1, "class", "svelte-1r5gmvu");
      add_location(canvas_1, file, 154, 1, 3526);
      attr_dev(div, "class", "svelte-1r5gmvu");
      add_location(div, file, 153, 0, 3519);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, canvas_1);
      ctx[22](canvas_1);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx[22](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Dotlottie", slots, []);
  function setWasmUrl2(url) {
    V3.setWasmUrl(url);
  }
  let { autoplay = false } = $$props;
  let { backgroundColor = void 0 } = $$props;
  let { data = void 0 } = $$props;
  let { loop = false } = $$props;
  let { mode = "forward" } = $$props;
  let { renderConfig = void 0 } = $$props;
  let { segment = void 0 } = $$props;
  let { speed = 1 } = $$props;
  let { src = void 0 } = $$props;
  let { useFrameInterpolation = true } = $$props;
  let { marker = void 0 } = $$props;
  let { layout = void 0 } = $$props;
  let { playOnHover = false } = $$props;
  let { animationId = "" } = $$props;
  let { themeId = "" } = $$props;
  let { themeData = "" } = $$props;
  let { dotLottieRefCallback = () => {
  } } = $$props;
  const hoverHandler = (event) => {
    if (!playOnHover || !dotLottie.isLoaded) return;
    if (event.type === "mouseenter") {
      dotLottie.play();
    } else if (event.type === "mouseleave") {
      dotLottie.pause();
    }
  };
  let dotLottie;
  let canvas;
  let prevSrc = void 0;
  let prevData = void 0;
  onMount(() => {
    const shouldAutoplay = autoplay && !playOnHover;
    $$invalidate(19, dotLottie = new V3({
      canvas,
      src,
      autoplay: shouldAutoplay,
      loop,
      speed,
      data,
      renderConfig,
      segment,
      useFrameInterpolation,
      backgroundColor,
      mode
    }));
    if (dotLottieRefCallback) {
      dotLottieRefCallback(dotLottie);
    }
    canvas.addEventListener("mouseenter", hoverHandler);
    canvas.addEventListener("mouseleave", hoverHandler);
    return () => {
      canvas.removeEventListener("mouseenter", hoverHandler);
      canvas.removeEventListener("mouseleave", hoverHandler);
      dotLottie.destroy();
    };
  });
  const writable_props = [
    "autoplay",
    "backgroundColor",
    "data",
    "loop",
    "mode",
    "renderConfig",
    "segment",
    "speed",
    "src",
    "useFrameInterpolation",
    "marker",
    "layout",
    "playOnHover",
    "animationId",
    "themeId",
    "themeData",
    "dotLottieRefCallback"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Dotlottie> was created with unknown prop '${key}'`);
  });
  function canvas_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      canvas = $$value;
      $$invalidate(0, canvas);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("autoplay" in $$props2) $$invalidate(2, autoplay = $$props2.autoplay);
    if ("backgroundColor" in $$props2) $$invalidate(3, backgroundColor = $$props2.backgroundColor);
    if ("data" in $$props2) $$invalidate(4, data = $$props2.data);
    if ("loop" in $$props2) $$invalidate(5, loop = $$props2.loop);
    if ("mode" in $$props2) $$invalidate(6, mode = $$props2.mode);
    if ("renderConfig" in $$props2) $$invalidate(7, renderConfig = $$props2.renderConfig);
    if ("segment" in $$props2) $$invalidate(8, segment = $$props2.segment);
    if ("speed" in $$props2) $$invalidate(9, speed = $$props2.speed);
    if ("src" in $$props2) $$invalidate(10, src = $$props2.src);
    if ("useFrameInterpolation" in $$props2) $$invalidate(11, useFrameInterpolation = $$props2.useFrameInterpolation);
    if ("marker" in $$props2) $$invalidate(12, marker = $$props2.marker);
    if ("layout" in $$props2) $$invalidate(13, layout = $$props2.layout);
    if ("playOnHover" in $$props2) $$invalidate(14, playOnHover = $$props2.playOnHover);
    if ("animationId" in $$props2) $$invalidate(15, animationId = $$props2.animationId);
    if ("themeId" in $$props2) $$invalidate(16, themeId = $$props2.themeId);
    if ("themeData" in $$props2) $$invalidate(17, themeData = $$props2.themeData);
    if ("dotLottieRefCallback" in $$props2) $$invalidate(18, dotLottieRefCallback = $$props2.dotLottieRefCallback);
  };
  $$self.$capture_state = () => ({
    onMount,
    DotLottie: V3,
    setWasmUrl: setWasmUrl2,
    autoplay,
    backgroundColor,
    data,
    loop,
    mode,
    renderConfig,
    segment,
    speed,
    src,
    useFrameInterpolation,
    marker,
    layout,
    playOnHover,
    animationId,
    themeId,
    themeData,
    dotLottieRefCallback,
    hoverHandler,
    dotLottie,
    canvas,
    prevSrc,
    prevData
  });
  $$self.$inject_state = ($$props2) => {
    if ("autoplay" in $$props2) $$invalidate(2, autoplay = $$props2.autoplay);
    if ("backgroundColor" in $$props2) $$invalidate(3, backgroundColor = $$props2.backgroundColor);
    if ("data" in $$props2) $$invalidate(4, data = $$props2.data);
    if ("loop" in $$props2) $$invalidate(5, loop = $$props2.loop);
    if ("mode" in $$props2) $$invalidate(6, mode = $$props2.mode);
    if ("renderConfig" in $$props2) $$invalidate(7, renderConfig = $$props2.renderConfig);
    if ("segment" in $$props2) $$invalidate(8, segment = $$props2.segment);
    if ("speed" in $$props2) $$invalidate(9, speed = $$props2.speed);
    if ("src" in $$props2) $$invalidate(10, src = $$props2.src);
    if ("useFrameInterpolation" in $$props2) $$invalidate(11, useFrameInterpolation = $$props2.useFrameInterpolation);
    if ("marker" in $$props2) $$invalidate(12, marker = $$props2.marker);
    if ("layout" in $$props2) $$invalidate(13, layout = $$props2.layout);
    if ("playOnHover" in $$props2) $$invalidate(14, playOnHover = $$props2.playOnHover);
    if ("animationId" in $$props2) $$invalidate(15, animationId = $$props2.animationId);
    if ("themeId" in $$props2) $$invalidate(16, themeId = $$props2.themeId);
    if ("themeData" in $$props2) $$invalidate(17, themeData = $$props2.themeData);
    if ("dotLottieRefCallback" in $$props2) $$invalidate(18, dotLottieRefCallback = $$props2.dotLottieRefCallback);
    if ("dotLottie" in $$props2) $$invalidate(19, dotLottie = $$props2.dotLottie);
    if ("canvas" in $$props2) $$invalidate(0, canvas = $$props2.canvas);
    if ("prevSrc" in $$props2) $$invalidate(20, prevSrc = $$props2.prevSrc);
    if ("prevData" in $$props2) $$invalidate(21, prevData = $$props2.prevData);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*dotLottie, layout*/
    532480) {
      $: {
        if (dotLottie && typeof layout === "object") {
          dotLottie.setLayout(layout);
        }
      }
    }
    if ($$self.$$.dirty & /*dotLottie, marker*/
    528384) {
      $: {
        if (dotLottie && typeof marker === "string") {
          dotLottie.setMarker(marker);
        }
      }
    }
    if ($$self.$$.dirty & /*dotLottie, speed*/
    524800) {
      $: {
        if (dotLottie && dotLottie.isLoaded && typeof speed == "number") {
          dotLottie.setSpeed(speed);
        }
      }
    }
    if ($$self.$$.dirty & /*dotLottie, useFrameInterpolation*/
    526336) {
      $: {
        if (dotLottie && dotLottie.isLoaded && typeof useFrameInterpolation == "boolean") {
          dotLottie.setUseFrameInterpolation(useFrameInterpolation);
        }
      }
    }
    if ($$self.$$.dirty & /*dotLottie, segment*/
    524544) {
      $: {
        if (dotLottie && dotLottie.isLoaded && Array.isArray(segment) && segment.length === 2 && typeof segment[0] === "number" && typeof segment[1] === "number") {
          let [start, end] = segment;
          dotLottie.setSegment(start, end);
        }
      }
    }
    if ($$self.$$.dirty & /*dotLottie, loop*/
    524320) {
      $: {
        if (dotLottie && dotLottie.isLoaded && typeof loop == "boolean") {
          dotLottie.setLoop(loop);
        }
      }
    }
    if ($$self.$$.dirty & /*dotLottie, backgroundColor*/
    524296) {
      $: {
        if (dotLottie) {
          dotLottie.setBackgroundColor(backgroundColor || "");
        }
      }
    }
    if ($$self.$$.dirty & /*dotLottie, mode*/
    524352) {
      $: {
        if (dotLottie && dotLottie.isLoaded && typeof mode == "string") {
          dotLottie.setMode(mode);
        }
      }
    }
    if ($$self.$$.dirty & /*dotLottie, src, prevSrc, autoplay, loop, speed, data, renderConfig, segment, useFrameInterpolation, backgroundColor, mode, marker, layout*/
    1589244) {
      $: if (dotLottie && src !== prevSrc) {
        dotLottie.load({
          src,
          autoplay,
          loop,
          speed,
          data,
          renderConfig,
          segment,
          useFrameInterpolation,
          backgroundColor,
          mode,
          marker,
          layout
        });
        $$invalidate(20, prevSrc = src);
      }
    }
    if ($$self.$$.dirty & /*dotLottie, data, prevData, src, autoplay, loop, speed, renderConfig, segment, useFrameInterpolation, backgroundColor, mode, marker, layout*/
    2637820) {
      $: if (dotLottie && data !== prevData) {
        dotLottie.load({
          src,
          autoplay,
          loop,
          speed,
          data,
          renderConfig,
          segment,
          useFrameInterpolation,
          backgroundColor,
          mode,
          marker,
          layout
        });
        $$invalidate(21, prevData = data);
      }
    }
    if ($$self.$$.dirty & /*dotLottie, animationId*/
    557056) {
      $: if (dotLottie && dotLottie.isLoaded && dotLottie.activeAnimationId !== animationId) {
        dotLottie.loadAnimation(animationId);
      }
    }
    if ($$self.$$.dirty & /*dotLottie, themeId*/
    589824) {
      $: if (dotLottie && dotLottie.isLoaded && dotLottie.activeThemeId !== themeId) {
        dotLottie.setTheme(themeId);
      }
    }
    if ($$self.$$.dirty & /*dotLottie, themeData*/
    655360) {
      $: if (dotLottie && dotLottie.isLoaded) {
        dotLottie.setThemeData(themeData);
      }
    }
  };
  return [
    canvas,
    setWasmUrl2,
    autoplay,
    backgroundColor,
    data,
    loop,
    mode,
    renderConfig,
    segment,
    speed,
    src,
    useFrameInterpolation,
    marker,
    layout,
    playOnHover,
    animationId,
    themeId,
    themeData,
    dotLottieRefCallback,
    dotLottie,
    prevSrc,
    prevData,
    canvas_1_binding
  ];
}
var Dotlottie = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        setWasmUrl: 1,
        autoplay: 2,
        backgroundColor: 3,
        data: 4,
        loop: 5,
        mode: 6,
        renderConfig: 7,
        segment: 8,
        speed: 9,
        src: 10,
        useFrameInterpolation: 11,
        marker: 12,
        layout: 13,
        playOnHover: 14,
        animationId: 15,
        themeId: 16,
        themeData: 17,
        dotLottieRefCallback: 18
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dotlottie",
      options,
      id: create_fragment.name
    });
  }
  get setWasmUrl() {
    return this.$$.ctx[1];
  }
  set setWasmUrl(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get autoplay() {
    throw new Error("<Dotlottie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set autoplay(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundColor() {
    throw new Error("<Dotlottie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundColor(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get data() {
    throw new Error("<Dotlottie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loop() {
    throw new Error("<Dotlottie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loop(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get mode() {
    throw new Error("<Dotlottie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set mode(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderConfig() {
    throw new Error("<Dotlottie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderConfig(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get segment() {
    throw new Error("<Dotlottie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set segment(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get speed() {
    throw new Error("<Dotlottie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set speed(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get src() {
    throw new Error("<Dotlottie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set src(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useFrameInterpolation() {
    throw new Error("<Dotlottie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useFrameInterpolation(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get marker() {
    throw new Error("<Dotlottie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set marker(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get layout() {
    throw new Error("<Dotlottie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set layout(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get playOnHover() {
    throw new Error("<Dotlottie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set playOnHover(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get animationId() {
    throw new Error("<Dotlottie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set animationId(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get themeId() {
    throw new Error("<Dotlottie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set themeId(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get themeData() {
    throw new Error("<Dotlottie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set themeData(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dotLottieRefCallback() {
    throw new Error("<Dotlottie>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dotLottieRefCallback(value) {
    throw new Error("<Dotlottie>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Dotlottie_default = Dotlottie;

// node_modules/@lottiefiles/dotlottie-svelte/dist/index.js
var setWasmUrl = (url) => {
  V3.setWasmUrl(url);
};
export {
  Dotlottie_default as DotLottieSvelte,
  setWasmUrl
};
//# sourceMappingURL=@lottiefiles_dotlottie-svelte.js.map
